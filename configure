#!/bin/sh
#
# Generated by qconf 1.5 ( http://delta.affinix.com/qconf/ )
#

show_usage() {
cat <<EOT
Usage: $0 [OPTION]...

This script creates necessary configuration files to build/install.

Main options:
  --prefix=[path]     Base path for build/install.  Default: /usr/local
  --bindir=[path]     Directory for binaries.  Default: PREFIX/bin
  --datadir=[path]    Directory for data.  Default: PREFIX/share
  --qtdir=[path]      Directory where Qt is installed.
  --verbose           Show extra configure output.
  --help              This help text.

Project options:
  --certstore-path=[path]    Path to the SSL/X509 Certificate store file
                             (bundled QCA only)

Dependency options:
  --disable-bundled-qca        Disable use of Use bundled QCA
  --disable-openssl            Disable use of OpenSSL (bundled QCA only)
  --with-openssl-inc=[path]    Path to OpenSSL include files (bundled QCA
                               only)
  --with-openssl-lib=[path]    Path to OpenSSL library files (bundled QCA
                               only)
  --with-zlib-inc=[path]       Path to zlib include files
  --with-zlib-lib=[path]       Path to zlib library files
  --enable-universal           Enable use of Mac OS X universal binary support
  --disable-qdbus              Disable use of QDBUS
  --disable-growl              Disable use of Growl
  --with-growl=[path]          Path to the Growl framework
  --disable-libnotify          Disable use of Notification Daemon Support
  --disable-sparkle            Disable use of Sparkle
  --with-sparkle=[path]        Path to the Sparkle framework
  --disable-xss                Disable use of the XScreenSaver extension
  --disable-ghbnr              Disable use of gethostbyname_r()
  --disable-aspell             Disable use of ASPELL
  --with-aspell-inc=[path]     Path to Aspell include files
  --with-aspell-lib=[path]     Path to Aspell library files
  --disable-plugins            Disable use of Plugins
  --enable-plugins             Enable Psi Plugin support
  --enable-debug               Enable debugging support

EOT
}

# which/make detection adapted from Qt
which_command() {
	OLD_HOME=$HOME
	HOME=/dev/null
	export HOME

	WHICH=`which which 2>/dev/null`
	if echo $WHICH | grep 'shell built-in command' >/dev/null 2>&1; then
		WHICH=which
	elif [ -z "$WHICH" ]; then
		if which which >/dev/null 2>&1; then
			WHICH=which
		else
			for a in /usr/ucb /usr/bin /bin /usr/local/bin; do
				if [ -x $a/which ]; then
					WHICH=$a/which
					break;
				fi
			done
		fi
	fi

	if [ -z "$WHICH" ]; then
		OLD_IFS=$IFS
		IFS=:
		for a in $PATH; do
			if [ -x $a/$1 ]; then
				echo "$a/$1"
				IFS=$OLD_IFS
				export IFS
				HOME=$OLD_HOME
				export HOME
				return 0
			fi
		done
		IFS=$OLD_IFS
		export IFS
	else
		a=`"$WHICH" "$1" 2>/dev/null`
		if [ ! -z "$a" -a -x "$a" ]; then
			echo "$a"
			HOME=$OLD_HOME
			export HOME
			return 0
		fi
	fi
	HOME=$OLD_HOME
	export HOME
	return 1
}
WHICH=which_command

# find a make command
if [ -z "$MAKE" ]; then
	MAKE=
	for mk in gmake make; do
		if $WHICH $mk >/dev/null 2>&1; then
			MAKE=`$WHICH $mk`
			break
		fi
	done
	if [ -z "$MAKE" ]; then
		echo "You don't seem to have 'make' or 'gmake' in your PATH."
		echo "Cannot proceed."
		exit 1
	fi
fi

show_qt_info() {
	printf "Be sure you have a proper Qt 4.0 build environment set up.  This means not\n"
	printf "just Qt, but also a C++ compiler, a make tool, and any other packages\n"
	printf "necessary for compiling C++ programs.\n"
	printf "\n"
	printf "If you are certain everything is installed, then it could be that Qt 4 is not\n"
	printf "being recognized or that a different version of Qt is being detected by\n"
	printf "mistake (for example, this could happen if \$QTDIR is pointing to a Qt 3\n"
	printf "installation).  At least one of the following conditions must be satisfied:\n"
	printf "\n"
	printf " 1) --qtdir is set to the location of Qt\n"
	printf " 2) \$QTDIR is set to the location of Qt\n"
	printf " 3) QtCore is in the pkg-config database\n"
	printf " 4) qmake is in the \$PATH\n"
	printf "\n"
	printf "This script will use the first one it finds to be true, checked in the above\n"
	printf "order.  #3 and #4 are the recommended options.  #1 and #2 are mainly for\n"
	printf "overriding the system configuration.\n"
	printf "\n"
}

while [ $# -gt 0 ]; do
	optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
	case "$1" in
		--prefix=*)
			PREFIX=$optarg
			shift
			;;

		--bindir=*)
			BINDIR=$optarg
			shift
			;;

		--datadir=*)
			DATADIR=$optarg
			shift
			;;

		--qtdir=*)
			EX_QTDIR=$optarg
			shift
			;;

		--certstore-path=*)
			QC_CERTSTORE_PATH=$optarg
			shift
			;;

		--disable-bundled-qca)
			QC_DISABLE_bundled_qca="Y"
			shift
			;;

		--disable-openssl)
			QC_DISABLE_openssl="Y"
			shift
			;;

		--with-openssl-inc=*)
			QC_WITH_OPENSSL_INC=$optarg
			shift
			;;

		--with-openssl-lib=*)
			QC_WITH_OPENSSL_LIB=$optarg
			shift
			;;

		--with-zlib-inc=*)
			QC_WITH_ZLIB_INC=$optarg
			shift
			;;

		--with-zlib-lib=*)
			QC_WITH_ZLIB_LIB=$optarg
			shift
			;;

		--enable-universal)
			QC_ENABLE_universal="Y"
			shift
			;;

		--disable-qdbus)
			QC_DISABLE_qdbus="Y"
			shift
			;;

		--disable-growl)
			QC_DISABLE_growl="Y"
			shift
			;;

		--with-growl=*)
			QC_WITH_GROWL=$optarg
			shift
			;;

		--disable-libnotify)
			QC_DISABLE_libnotify="Y"
			shift
			;;

		--disable-sparkle)
			QC_DISABLE_sparkle="Y"
			shift
			;;

		--with-sparkle=*)
			QC_WITH_SPARKLE=$optarg
			shift
			;;

		--disable-xss)
			QC_DISABLE_xss="Y"
			shift
			;;

		--disable-ghbnr)
			QC_DISABLE_ghbnr="Y"
			shift
			;;

		--disable-aspell)
			QC_DISABLE_aspell="Y"
			shift
			;;

		--with-aspell-inc=*)
			QC_WITH_ASPELL_INC=$optarg
			shift
			;;

		--with-aspell-lib=*)
			QC_WITH_ASPELL_LIB=$optarg
			shift
			;;

		--disable-plugins)
			QC_DISABLE_plugins="Y"
			shift
			;;

		--enable-plugins)
			QC_ENABLE_PLUGINS="Y"
			shift
			;;

		--enable-debug)
			QC_ENABLE_DEBUG="Y"
			shift
			;;

		--verbose)
			QC_VERBOSE="Y"
			shift
			;;
		--help) show_usage; exit ;;
		*) show_usage; exit ;;
	esac
done

PREFIX=${PREFIX:-/usr/local}
BINDIR=${BINDIR:-$PREFIX/bin}
DATADIR=${DATADIR:-$PREFIX/share}

echo "Configuring Psi ..."

if [ "$QC_VERBOSE" = "Y" ]; then
echo
echo PREFIX=$PREFIX
echo BINDIR=$BINDIR
echo DATADIR=$DATADIR
echo EX_QTDIR=$EX_QTDIR
echo QC_CERTSTORE_PATH=$QC_CERTSTORE_PATH
echo QC_DISABLE_bundled_qca=$QC_DISABLE_bundled_qca
echo QC_DISABLE_openssl=$QC_DISABLE_openssl
echo QC_WITH_OPENSSL_INC=$QC_WITH_OPENSSL_INC
echo QC_WITH_OPENSSL_LIB=$QC_WITH_OPENSSL_LIB
echo QC_WITH_ZLIB_INC=$QC_WITH_ZLIB_INC
echo QC_WITH_ZLIB_LIB=$QC_WITH_ZLIB_LIB
echo QC_ENABLE_universal=$QC_ENABLE_universal
echo QC_DISABLE_qdbus=$QC_DISABLE_qdbus
echo QC_DISABLE_growl=$QC_DISABLE_growl
echo QC_WITH_GROWL=$QC_WITH_GROWL
echo QC_DISABLE_libnotify=$QC_DISABLE_libnotify
echo QC_DISABLE_sparkle=$QC_DISABLE_sparkle
echo QC_WITH_SPARKLE=$QC_WITH_SPARKLE
echo QC_DISABLE_xss=$QC_DISABLE_xss
echo QC_DISABLE_ghbnr=$QC_DISABLE_ghbnr
echo QC_DISABLE_aspell=$QC_DISABLE_aspell
echo QC_WITH_ASPELL_INC=$QC_WITH_ASPELL_INC
echo QC_WITH_ASPELL_LIB=$QC_WITH_ASPELL_LIB
echo QC_DISABLE_plugins=$QC_DISABLE_plugins
echo QC_ENABLE_PLUGINS=$QC_ENABLE_PLUGINS
echo QC_ENABLE_DEBUG=$QC_ENABLE_DEBUG
echo
fi

printf "Verifying Qt 4 build environment ... "

# run qmake -v and check version
qmake_check_v4() {
	if [ -x "$1" ]; then
		if echo `$1 -v 2>&1` | grep "Qt version 4\." >/dev/null 2>&1; then
			return 0
		elif [ "$QC_VERBOSE" = "Y" ]; then
			echo "Warning: $1 not for Qt 4"
		fi
	fi
	return 1
}

if [ "$QC_VERBOSE" = "Y" ]; then
	echo
fi

qm=""
names="qmake-qt4 qmake4 qmake"

# qt4 check: --qtdir
if [ -z "$qm" ] && [ ! -z "$EX_QTDIR" ]; then
	for n in $names; do
		qstr=$EX_QTDIR/bin/$n
		if qmake_check_v4 "$qstr"; then
			qm=$qstr
			break;
		fi
	done
fi
if [ -z "$qm" ] && [ "$QC_VERBOSE" = "Y" ]; then
	echo "Warning: qmake not found via --qtdir"
fi

# qt4 check: QTDIR
if [ -z "$qm" ] && [ ! -z "$QTDIR" ]; then
	for n in $names; do
		qstr=$QTDIR/bin/$n
		if qmake_check_v4 "$qstr"; then
			qm=$qstr
			break;
		fi
	done
fi
if [ -z "$qm" ] && [ "$QC_VERBOSE" = "Y" ]; then
	echo "Warning: qmake not found via \$QTDIR"
fi

# qt4 check: pkg-config
if [ -z "$qm" ]; then
	str=`pkg-config QtCore --variable=exec_prefix 2>/dev/null`
	if [ ! -z "$str" ]; then
		for n in $names; do
			qstr=$str/bin/$n
			if qmake_check_v4 "$qstr"; then
				qm=$qstr
				break;
			fi
		done
	fi
fi
if [ -z "$qm" ] && [ "$QC_VERBOSE" = "Y" ]; then
	echo "Warning: qmake not found via pkg-config"
fi

# qt4 check: PATH
if [ -z "$qm" ]; then
	for n in $names; do
		qstr=`$WHICH $n 2>/dev/null`
		if qmake_check_v4 "$qstr"; then
			qm=$qstr
			break;
		fi
	done
fi
if [ -z "$qm" ] && [ "$QC_VERBOSE" = "Y" ]; then
	echo "Warning: qmake not found via \$PATH"
fi

if [ -z "$qm" ]; then
	if [ "$QC_VERBOSE" = "Y" ]; then
		echo " -> fail"
	else
		echo "fail"
	fi
	printf "\n"
	printf "Reason: Unable to find the 'qmake' tool for Qt 4.\n"
	printf "\n"
	show_qt_info
	exit 1;
fi
if [ "$QC_VERBOSE" = "Y" ]; then
	echo qmake found in $qm
fi

# try to determine the active makespec
defmakespec=$QMAKESPEC
if [ -z "$defmakespec" ]; then
	if $WHICH readlink >/dev/null 2>&1; then
		READLINK=`$WHICH readlink`
	fi
	if [ ! -z "$READLINK" ]; then
		qt_mkspecsdir=`$qm -query QT_INSTALL_DATA`/mkspecs
		if [ -d "$qt_mkspecsdir" ] && [ -h "$qt_mkspecsdir/default" ]; then
			defmakespec=`$READLINK $qt_mkspecsdir/default`
		fi
	fi
fi

if [ "$QC_VERBOSE" = "Y" ]; then
	echo makespec is $defmakespec
fi

qm_spec=""
# if the makespec is macx-xcode, force macx-g++
if [ "$defmakespec" = "macx-xcode" ]; then
	qm_spec=macx-g++
	QMAKESPEC=$qm_spec
	export QMAKESPEC
	if [ "$QC_VERBOSE" = "Y" ]; then
		echo overriding makespec to $qm_spec
	fi
fi

gen_files() {
cat >$1/modules.cpp <<EOT
#line 1 "qt4.qcm"
/*
-----BEGIN QCMOD-----
name: Qt >= 4.1
-----END QCMOD-----
*/
class qc_qt4 : public ConfObj
{
public:
	qc_qt4(Conf *c) : ConfObj(c) {}
	QString name() const { return "Qt >= 4.2.3"; }
	QString shortname() const { return "qt4"; }
	bool exec()
	{
		return(QT_VERSION >= 0x040203);
	}
};
#line 1 "bundled-qca.qcm"
/*
-----BEGIN QCMOD-----
name: Use bundled QCA
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_bundled_qca
//----------------------------------------------------------------------------
class qc_bundled_qca : public ConfObj
{
public:
	qc_bundled_qca(Conf *c) : ConfObj(c) {}
	QString name() const { return "bundled QCA 2.0"; }
	QString shortname() const { return "bundled_qca"; }

	bool exec()
	{
		// FIXME: Check QCA version number
		if (QFile::exists("third-party/qca/qca")) {
			conf->addExtra("CONFIG += qca-static");
			conf->addDefine("QCA_NO_PLUGINS");
			return true;
		}
		else {
			return false;
		}
	}
};
#line 1 "qca.qcm"
/*
-----BEGIN QCMOD-----
name: external QCA 2.0
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_qca
//----------------------------------------------------------------------------
class qc_qca : public ConfObj
{
public:
	qc_qca(Conf *c) : ConfObj(c) {}
	QString name() const { return "QCA 2.0"; }
	QString shortname() const { return "qca"; }

	QString checkString() const {
		if (QFile::exists("third-party/qca/qca") && conf->getenv("QC_DISABLE_bundled_qca").isEmpty())
			return "";
		else
			return ConfObj::checkString();
	}

	bool exec()
	{
		// Check if we have a bundnled version
		if (QFile::exists("third-party/qca/qca") && conf->getenv("QC_DISABLE_bundled_qca").isEmpty())
			return true;

		// test for "crypto" feature and check qca version number

		QString proextra =
		"CONFIG += qt crypto\n"
		"QT -= gui\n";

		QString str =
		"#include <QtCrypto>\n"
		"\n"
		"int main()\n"
		"{\n"
		"	unsigned long x = QCA_VERSION;\n"
		"	if(x >= 0x020000 && x < 0x030000) return 0; else return 1;\n"
		"}\n";

		int ret;
		if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra, &ret))
			return false;
		if(ret != 0)
			return false;

		return true;
	}
};
#line 1 "openssl.qcm"
/*
-----BEGIN QCMOD-----
name: OpenSSL (bundled QCA only)
arg: with-openssl-inc=[path],Path to OpenSSL include files (bundled QCA only)
arg: with-openssl-lib=[path],Path to OpenSSL library files (bundled QCA only)
-----END QCMOD-----
*/
class qc_openssl : public ConfObj
{
public:
	qc_openssl(Conf *c) : ConfObj(c) {}
	QString name() const { return "OpenSSL"; }
	QString shortname() const { return "openssl"; }

	QString checkString() const {
		if (!QFile::exists("third-party/qca/qca") || !conf->getenv("QC_DISABLE_bundled_qca").isEmpty())
			return "";
		else
			return ConfObj::checkString();
	}

	bool exec()
	{
		if (!QFile::exists("third-party/qca/qca") || !conf->getenv("QC_DISABLE_bundled_qca").isEmpty() || !QFile::exists("third-party/qca/qca-ossl"))
			return false;

		QString inc, lib;
		QString s;
		bool kb = false;
		QString kbdir = "/usr/kerberos/include";

		// Redhat 9?
		if(QFileInfo(kbdir).exists())
			kb = true;

		s = conf->getenv("QC_WITH_OPENSSL_INC");
		if(!s.isEmpty()) {
			if(!conf->checkHeader(s, "openssl/ssl.h"))
				return false;
			inc = s;
		}
		else {
			if(!conf->findHeader("openssl/ssl.h", QStringList(), &s))
				return false;
			inc = s;
		}

		s = conf->getenv("QC_WITH_OPENSSL_LIB");
		if(!s.isEmpty()) {
			if(!conf->checkLibrary(s, "ssl"))
				return false;
			lib = s;
		}
		else {
			if(!conf->findLibrary("ssl", &s))
				return false;
			lib = s;
		}

		// is it at least openssl 0.9.7?
		QString str =
			"#include<openssl/opensslv.h>\n"
			"int main()\n"
			"{\n"
			"  unsigned long x = OPENSSL_VERSION_NUMBER;\n"
			"  if(x >= 0x00907000) return 0; else return 1;\n"
			"}\n";
		QString ext;
		QStringList incs;
		if(!inc.isEmpty())
			incs += inc;
		if(kb)
			incs += kbdir;
		if(!lib.isEmpty())
			ext += QString("-L") + lib + " -lssl -lcrypto ";
		int ret;
		if(!conf->doCompileAndLink(str, incs, ext, QString(), &ret))
			return false;
		if(ret == 0)
			conf->addDefine("OSSL_097");

		if(!inc.isEmpty())
			conf->addIncludePath(inc);
		if(kb)
			conf->addIncludePath(kbdir);
		if(!lib.isEmpty())
			conf->addLib(QString("-L") + s);
		conf->addLib("-lssl -lcrypto");
		
		conf->addDefine("HAVE_OPENSSL");

		return true;
	}
};
#line 1 "zlib.qcm"
/*
-----BEGIN QCMOD-----
name: zlib
arg: with-zlib-inc=[path],Path to zlib include files
arg: with-zlib-lib=[path],Path to zlib library files
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_zlib
//----------------------------------------------------------------------------
class qc_zlib : public ConfObj
{
public:
	qc_zlib(Conf *c) : ConfObj(c) {}
	QString name() const { return "zlib"; }
	QString shortname() const { return "zlib"; }
	bool exec()
	{
		QString inc, lib;
		QString s;

		s = conf->getenv("QC_WITH_ZLIB_INC");
		if(!s.isEmpty()) {
			if(!conf->checkHeader(s, "zlib.h"))
				return false;
			inc = s;
		}
		else {
			if(!conf->findHeader("zlib.h", QStringList(), &s))
				return false;
			inc = s;
		}

		s = conf->getenv("QC_WITH_ZLIB_LIB");
		if(!s.isEmpty()) {
			if(!conf->checkLibrary(s, "z"))
				return false;
			lib = s;
		}
		else {
			if(!conf->findLibrary("z", &s))
				return false;
			lib = s;
		}

		if(!inc.isEmpty())
			conf->addIncludePath(inc);
		if(!lib.isEmpty())
			conf->addLib(QString("-L") + s);
		conf->addLib("-lz");

		return true;
	}
};
#line 1 "universal.qcm"
/*
-----BEGIN QCMOD-----
name: Mac OS X universal binary support
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_universal
//----------------------------------------------------------------------------
class qc_universal : public ConfObj
{
public:
	qc_universal(Conf *c) : ConfObj(c) {}
	QString name() const { return "universal binary support"; }
	QString shortname() const { return "universal"; }
	QString checkString() const { return QString(); }

	bool exec()
	{
#ifdef Q_WS_MAC
		conf->addExtra("CONFIG += qc_universal");
#endif
		return true;
	}
};
#line 1 "certstore.qcm"
/*
-----BEGIN QCMOD-----
name: certstore
section: project
arg: certstore-path=[path],Path to the SSL/X509 Certificate store file (bundled QCA only)
-----END QCMOD-----
*/

class qc_certstore : public ConfObj
{
public:
	qc_certstore(Conf *c) : ConfObj(c) {}
	QString name() const { return "certstore"; }
	QString shortname() const { return "certstore"; }

	QString checkString() const {
		if (!QFile::exists("third-party/qca/qca") || !conf->getenv("QC_DISABLE_bundled_qca").isEmpty())
			return "";
		else
			return ConfObj::checkString();
	}

	bool exec()
	{
		if (!QFile::exists("third-party/qca/qca") || !conf->getenv("QC_DISABLE_bundled_qca").isEmpty() || !QFile::exists("third-party/qca/qca-ossl")) {
			return true;
		}
			
		bundled = false;

#if defined(Q_OS_WIN) || defined(Q_OS_MAC)
		// use built-in
		return true;
#else
		QStringList pathsToTry;

		path = conf->getenv("QC_CERTSTORE_PATH");
		if(!path.isEmpty())
		{
			if(QFile::exists(path))
			{
				QString certPathString = 
					"QCA_SYSTEMSTORE_PATH=\\\\\\\\\\\\\"" + path + "\\\\\\\\\\\\\"";
				conf->addDefine(certPathString);
				return true;
			}
			return false;
		}

		// This is from Debian
		pathsToTry.append( QString("/etc/ssl/certs/ca-certificates.crt") );

		// Fedora Core 2 uses these
		pathsToTry.append( QString("/usr/share/ssl/cert.pem") );
		pathsToTry.append( QString("/usr/share/ssl/certs/ca-bundle.crt") );

		// Fedora Core 5 changes to this
		pathsToTry.append( QString("/etc/pki/tls/cert.pem") );

		for(int n = 0; n < pathsToTry.count(); ++n)
		{
        		if(QFile::exists(pathsToTry[n]))
			{
				path = pathsToTry[n];
				break;
			}
		}

		// fall back to bundled
		if(path.isEmpty())
		{
			// --prefix=\$pwd ?
			if(QFile::exists(conf->getenv("PREFIX") + "/certs/rootcerts.pem"))
				path = "\$\$PREFIX/certs/rootcerts.pem";
			else
				path = "\$\$DATADIR/psi/certs/rootcerts.pem";

			QString extra =
			"qcasharedfiles.path = \$\$DATADIR/psi\n"
			"qcasharedfiles.files = third-party/qca/qca/certs\n"
			"INSTALLS += qcasharedfiles\n";
			conf->addExtra(extra);
			bundled = true;
		}

		// Qt<4.2 workaround
		QString certPathString = 
			"QCA_SYSTEMSTORE_PATH=\\\\\\\\\\\\\"" + path + "\\\\\\\\\\\\\"";
		conf->addDefine(certPathString);

		return true;
#endif
	}

	QString resultString() const
	{
#if defined(Q_OS_WIN)
		return "using Windows built-in";
#elif defined(Q_OS_MAC)
		return "using Mac built-in";
#else
		if(success)
		{
			if(bundled)
				return "using bundled";
			else
				return path;
		}
		else
			return ConfObj::resultString();
#endif
	}

private:
	QString path;
	bool bundled;
};
#line 1 "qdbus.qcm"
/*
-----BEGIN QCMOD-----
name: QDBUS
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_qdbus
//----------------------------------------------------------------------------
class qc_qdbus : public ConfObj
{
public:
	qc_qdbus(Conf *c) : ConfObj(c) {}
	QString name() const { return "QDBUS"; }
	QString shortname() const { return "qdbus"; }
	bool exec()
	{
		if (!conf->getenv("QC_DISABLE_qdbus").isEmpty())
			return false;

		// test for "qdbus" feature

		QString proextra =
		"CONFIG += qt qdbus\n"
		"QT -= gui\n";

		QString str =
		"\n"
		"int main()\n"
		"{\n"
		"	return 0;\n"
		"}\n";

		int ret;
		if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra, &ret))
			return false;
		if(ret != 0)
			return false;
		
		conf->addExtra("CONFIG += dbus");
		return true;
	}
};
#line 1 "growl.qcm"
/*
-----BEGIN QCMOD-----
name: Growl
arg: with-growl=[path],Path to the Growl framework
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_growl
//----------------------------------------------------------------------------
class qc_growl : public ConfObj
{
public:
	qc_growl(Conf *c) : ConfObj(c) {}
	QString name() const { return "Growl"; }
	QString shortname() const { return "growl"; }
#ifndef Q_WS_MAC
	QString checkString() const { return QString(); }
#endif

	// TODO: This should go into ConfObj
    bool checkFramework(const QString &path, const QString &name)
    {
        QString str =
            "int main()\n"
            "{\n"
            "    return 0;\n"
            "}\n";

        QString extra;
        if(!path.isEmpty())
            extra += QString("-F") + path + ' ';
        extra += QString("-framework ") + name;
        if(!conf->doCompileAndLink(str, QStringList(), extra, "", NULL))
            return false;
        return true;
    }
	
	// TODO: This should go into ConfObj
	void addFrameworkPath(const QString& str)
	{
		conf->addExtra("QMAKE_CXXFLAGS += -F" + str);
		conf->addLib("-F" + str);
	}

	bool exec()
	{
#ifdef Q_WS_MAC
		QString growl_path = conf->getenv("QC_WITH_GROWL");
		if(!checkFramework(growl_path, "Growl"))
			return false;

		if(!growl_path.isEmpty()) 
			addFrameworkPath(growl_path);
		conf->addLib("-framework Growl");
		conf->addDefine("HAVE_GROWL");

		return true;
#else
		return false;
#endif
	}
};
#line 1 "libnotify.qcm"
/*
-----BEGIN QCMOD-----
name: Notification Daemon Support
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_universal
//----------------------------------------------------------------------------
class qc_libnotify : public ConfObj
{
public:
  qc_libnotify(Conf *c) : ConfObj(c) {}
  QString name() const { return "Notification daemon support"; }
  QString shortname() const { return "libnotify"; }
  
  bool exec()
  {
    QString version,libs;
    QStringList incs;
    QByteArray out;
    int i;

    // gtkmm seems neccessary, although pkg-config should do this for us.	


    if (!conf->findPkgConfig(QString("gtkmm-2.4"),VersionAny,QString(),&version,&incs,&libs,&QString()))
    {
        return false;
        qWarning("Couldn't find gtkmm 2.4.");
    }

   
    i=0;
    while(i<incs.count())
      conf->addIncludePath(incs[i++]);

    conf->addLib(libs);

	 
    if (!conf->findPkgConfig(QString("libnotifymm-1.0"),VersionAny,QString(),&version,&incs,&libs,&QString()))
      {
	return false;
	qWarning("Couldn't find libnotifymm 1.0.");
      }
  

    i=0;
    while(i<incs.count())
      conf->addIncludePath(incs[i++]);

    conf->addLib(libs);
    conf->addDefine("HAVE_LIBNOTIFY");

    return true;
  }
};
#line 1 "sparkle.qcm"
/*
-----BEGIN QCMOD-----
name: Sparkle
arg: with-sparkle=[path],Path to the Sparkle framework
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_sparkle
//----------------------------------------------------------------------------

class qc_sparkle : public ConfObj
{
	public:
		qc_sparkle(Conf *c) : ConfObj(c) {}

		QString name() const { return "Sparkle"; }
		QString shortname() const { return "sparkle"; }
#ifndef Q_WS_MAC
		QString checkString() const { return QString(); }
#endif

		// TODO: This should go into ConfObj
		bool checkFramework(const QString &path, const QString &name)
		{
				QString str = "int main() { return 0; }";

				QString extra;
				if(!path.isEmpty()) {
						extra += QString("-F") + path + ' ';
				}
				extra += QString("-framework ") + name;
				if(!conf->doCompileAndLink(str, QStringList(), extra, "", NULL)) {
						return false;
				}
				return true;
		}
		
		// TODO: This should go into ConfObj
		void addFrameworkPath(const QString& str)
		{
			conf->addExtra("QMAKE_CXXFLAGS += -F" + str);
			conf->addLib("-F" + str);
		}

		bool exec()
		{
#ifdef Q_WS_MAC
			QString sparkle_path = conf->getenv("QC_WITH_SPARKLE");
			if(!checkFramework(sparkle_path, "Sparkle"))
				return false;

			if(!sparkle_path.isEmpty()) {
				addFrameworkPath(sparkle_path);
			}
			conf->addExtra("CONFIG += Sparkle");
			conf->addDefine("HAVE_SPARKLE");

			return true;
#else
			return false;
#endif
		}
};
#line 1 "xss.qcm"
/*
-----BEGIN QCMOD-----
name: the XScreenSaver extension
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_xss
//----------------------------------------------------------------------------
class qc_xss : public ConfObj
{
public:
	qc_xss(Conf *c) : ConfObj(c) {}

	QString name() const { return "the XScreenSaver extension"; }
	QString shortname() const { return "xss"; }

	bool exec()
	{
		QString str =
			"#include<X11/Xlib.h>\n"
			"#include<X11/Xutil.h>\n"
			"#include<X11/extensions/scrnsaver.h>\n"
			"\n"
			"int main()\n"
			"{\n"
			"    XScreenSaverQueryExtension(NULL, NULL, NULL);\n"
			"    return 0;\n"
			"}\n";
		QString proextra = "CONFIG += x11\n";

		if (!conf->doCompileAndLink(str, QStringList(), "-lXss", proextra, NULL)) {
			if (!conf->doCompileAndLink(str, QStringList(), QString(), proextra, NULL)) {
				return false;
			}
		}
		else {
			conf->addLib("-lXss");
		}
		
		conf->addDefine("HAVE_XSS");
		return true;
	}
};
#line 1 "ghbnr.qcm"
/*
-----BEGIN QCMOD-----
name: gethostbyname_r()
-----END QCMOD-----
*/
class qc_ghbnr : public ConfObj
{
public:
	qc_ghbnr(Conf *c) : ConfObj(c) { }

	QString name() const { return "gethostbyname_r()"; }
	QString shortname() const { return "ghbnr"; }

	bool exec()
	{
		QString str =
			"#include<netdb.h>\n"
			"\n"
			"int main()\n"
			"{\n"
			"    gethostbyname_r(\"\", 0, 0, 0, 0, 0);\n"
			"    return 0;\n"
			"}\n";
		if (!conf->doCompileAndLink(str, QStringList(), QString(), QString(), NULL))
			return false;
			
		conf->addDefine("HAVE_GETHOSTBYNAME_R");
		return true;
	}
};
#line 1 "aspell.qcm"
/*
-----BEGIN QCMOD-----
name: ASPELL
arg: with-aspell-inc=[path],Path to Aspell include files
arg: with-aspell-lib=[path],Path to Aspell library files
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_spell
//----------------------------------------------------------------------------
class qc_aspell : public ConfObj
{
public:
	qc_aspell(Conf *c) : ConfObj(c) {}
	QString name() const { return "Aspell support"; }
	QString shortname() const { return "aspell"; }
	bool exec()
	{
		QString s;

		s = conf->getenv("QC_WITH_ASPELL_INC");
		if(!s.isEmpty()) {
			if(!conf->checkHeader(s, "aspell.h")) {
				conf->debug("Aspell includes not found!");
				return false;
			}
			conf->addIncludePath(s);
		}
		else {
			QStringList sl;
			sl += "/usr/include";
			sl += "/usr/local/include";
			sl += "/sw/include";
			if(!conf->findHeader("aspell.h", sl, &s)) {
				conf->debug("Aspell includes not found!");
				return false;
			}
			conf->addIncludePath(s);
		}

		s = conf->getenv("QC_WITH_ASPELL_LIB");
		if(!s.isEmpty()) {
			if(!conf->checkLibrary(s, "aspell")) {
				conf->debug("Aspell libraries not found!");
				return false;
			}
			conf->addLib(QString("-L") + s);
		}
		else {
			if(!conf->findLibrary("aspell", &s)) {
				conf->debug("Aspell libraries not found!");
				return false;
			}
			if (!s.isEmpty())
				conf->addLib(QString("-L") + s);
		}

		conf->addLib("-laspell");
		conf->addDefine("HAVE_ASPELL");

		return true;
	}
};
#line 1 "plugins.qcm"
/*
-----BEGIN QCMOD-----
name: Plugins
arg: enable-plugins,Enable Psi Plugin support

-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_plugins
//----------------------------------------------------------------------------
class qc_plugins : public ConfObj
{
public:
	qc_plugins(Conf *c) : ConfObj(c) {}
	QString name() const { return "Plugins"; }
	QString shortname() const { return "Plugins"; }
	bool exec()
	{
		QString s;
		
		// Check if Jingle was enabled explicitly
		s = conf->getenv("QC_ENABLE_PLUGINS");
		if(s.isEmpty())
			return false;
		
		conf->addDefine("PSI_PLUGINS");
		
		// Finish
		conf->addExtra("CONFIG += psi_plugins");                              

		qWarning("");
		qWarning("");
		qWarning("        !!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!");
		qWarning("        PLUGIN SUPPORT IS STILL UNFINISHED !!!");
		qWarning("        THE PLUGIN INTERFACE /WILL/ CHANGE !!!");
		qWarning("        USE AT YOUR OWN RISK !!!");

		return true;
	}
};
#line 1 "debug.qcm"
/*
-----BEGIN QCMOD-----
name: Debugging support
arg: enable-debug,Enable debugging support
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_debug
//----------------------------------------------------------------------------
class qc_debug : public ConfObj
{
public:
	qc_debug(Conf *c) : ConfObj(c) {}
	QString name() const { return "debugging support"; }
	QString shortname() const { return "debug"; }
	QString checkString() const { return QString(); }

	bool exec()
	{
		if (conf->getenv("QC_ENABLE_DEBUG").isEmpty())
			conf->addExtra("CONFIG += release");
		else
			conf->addExtra("CONFIG += debug");
		return true;
	}
};
#line 1 "conf.qcm"
/*
-----BEGIN QCMOD-----
name: Psi Configuration
-----END QCMOD-----
*/

//----------------------------------------------------------------------------
// qc_conf
//----------------------------------------------------------------------------
class qc_conf : public ConfObj
{
public:
	qc_conf(Conf *c) : ConfObj(c) {}
	QString name() const { return "Psi Configuration"; }
	QString shortname() const { return "conf"; }
	QString checkString() const { return QString(); }
	bool exec()
	{
		conf->addExtra(QString("PSI_DATADIR=%1/psi").arg(conf->getenv("DATADIR")));

		QFile file("src/config.h");
		if ( file.open(QIODevice::WriteOnly | QIODevice::Text) ) {
			QTextStream stream( &file );
			stream << "#define PSI_DATADIR \"" << conf->getenv("DATADIR") << "/psi\"" << endl;
		}
		
		conf->addDefine("HAVE_CONFIG");
		
		return true;
	}
};

EOT
cat >$1/modules_new.cpp <<EOT
    o = new qc_qt4(conf);
    o->required = true;
    o->disabled = false;
    o = new qc_bundled_qca(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_qca(conf);
    o->required = true;
    o->disabled = false;
    o = new qc_openssl(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_zlib(conf);
    o->required = true;
    o->disabled = false;
    o = new qc_universal(conf);
    o->required = false;
    o->disabled = true;
    o = new qc_certstore(conf);
    o->required = true;
    o->disabled = false;
    o = new qc_qdbus(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_growl(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_libnotify(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_sparkle(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_xss(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_ghbnr(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_aspell(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_plugins(conf);
    o->required = false;
    o->disabled = false;
    o = new qc_debug(conf);
    o->required = true;
    o->disabled = false;
    o = new qc_conf(conf);
    o->required = true;
    o->disabled = false;

EOT
cat >$1/conf4.h <<EOT
/*
Copyright (C) 2004-2008  Justin Karneges

This file is free software; unlimited permission is given to copy and/or
distribute it, with or without modifications, as long as this notice is
preserved.
*/

#ifndef QC_CONF4_H
#define QC_CONF4_H

#include <QtCore>

class Conf;

enum VersionMode { VersionMin, VersionExact, VersionMax, VersionAny };

// ConfObj
//
// Subclass ConfObj to create a new configuration module.
class ConfObj
{
public:
	Conf *conf;
	bool required;
	bool disabled;
	bool success;

	ConfObj(Conf *c);
	virtual ~ConfObj();

	// long or descriptive name of what is being checked/performed
	// example: "KDE >= 3.3"
	virtual QString name() const = 0;

	// short name
	// example: "kde"
	virtual QString shortname() const = 0;

	// string to display during check
	// default: "Checking for [name] ..."
	virtual QString checkString() const;

	// string to display after check
	// default: "yes" or "no", based on result of exec()
	virtual QString resultString() const;

	// this is where the checking code goes
	virtual bool exec() = 0;
};

// Conf
//
// Interact with this class from your ConfObj to perform detection
// operations and to output configuration parameters.
class Conf
{
public:
	bool debug_enabled;
	QString qmake_path;
	QString qmakespec;
	QString maketool;

	QString DEFINES;
	QString INCLUDEPATH;
	QString LIBS;
	QString extra;

	QList<ConfObj*> list;
	QMap<QString,QString> vars;

	Conf();
	~Conf();

	QString getenv(const QString &var);
	QString qvar(const QString &s);

	bool exec();

	void debug(const QString &s);

	QString expandIncludes(const QString &inc);
	QString expandLibs(const QString &lib);

	int doCommand(const QString &s, QByteArray *out = 0);
	int doCommand(const QString &prog, const QStringList &args, QByteArray *out = 0);

	bool doCompileAndLink(const QString &filedata, const QStringList &incs, const QString &libs, const QString &proextra, int *retcode = 0);
	bool checkHeader(const QString &path, const QString &h);
	bool findHeader(const QString &h, const QStringList &ext, QString *inc);
	bool checkLibrary(const QString &path, const QString &name);
	bool findLibrary(const QString &name, QString *lib);
	QString findProgram(const QString &prog);
	bool findSimpleLibrary(const QString &incvar, const QString &libvar, const QString &incname, const QString &libname, QString *incpath, QString *libs);
	bool findFooConfig(const QString &path, QString *version, QStringList *incs, QString *libs, QString *otherflags);
	bool findPkgConfig(const QString &name, VersionMode mode, const QString &req_version, QString *version, QStringList *incs, QString *libs, QString *otherflags);

	void addDefine(const QString &str);
	void addLib(const QString &str);
	void addIncludePath(const QString &str);
	void addExtra(const QString &str);

private:
	bool first_debug;

	friend class ConfObj;
	void added(ConfObj *o);
};

#endif

EOT
cat >$1/conf4.cpp <<EOT
/*
Copyright (C) 2004-2008  Justin Karneges

This file is free software; unlimited permission is given to copy and/or
distribute it, with or without modifications, as long as this notice is
preserved.
*/

#include "conf4.h"

#include <stdio.h>
#include <stdlib.h>

class MocTestObject : public QObject
{
	Q_OBJECT
public:
	MocTestObject() {}
};

QString qc_getenv(const QString &var)
{
	char *p = ::getenv(var.toLatin1().data());
	if(!p)
		return QString();
	return QString(p);
}

QStringList qc_pathlist()
{
	QStringList list;
	QString path = qc_getenv("PATH");
	if(!path.isEmpty())
	{
#ifdef Q_OS_WIN
		list = path.split(';', QString::SkipEmptyParts);
#else
		list = path.split(':', QString::SkipEmptyParts);
#endif
	}
#ifdef Q_OS_WIN
	list.prepend(".");
#endif
	return list;
}

QString qc_findprogram(const QString &prog)
{
	QString out;
	QStringList list = qc_pathlist();
	for(int n = 0; n < list.count(); ++n)
	{
		QFileInfo fi(list[n] + '/' + prog);
		if(fi.exists() && fi.isExecutable())
		{
			out = fi.filePath();
			break;
		}

#ifdef Q_OS_WIN
		// on windows, be sure to look for .exe
		if(prog.right(4).toLower() != ".exe")
		{
			fi = QFileInfo(list[n] + '/' + prog + ".exe");
			if(fi.exists() && fi.isExecutable())
			{
				out = fi.filePath();
				break;
			}
		}
#endif
	}
	return out;
}

QString qc_findself(const QString &argv0)
{
#ifdef Q_OS_WIN
	if(argv0.contains('\\'))
#else
	if(argv0.contains('/'))
#endif
		return argv0;
	else
		return qc_findprogram(argv0);
}

int qc_runcommand(const QString &command, QByteArray *out, bool showOutput)
{
	QString fullcmd = command;
	if(!showOutput)
		fullcmd += " 2>/dev/null";
	FILE *f = popen(fullcmd.toLatin1().data(), "r");
	if(!f)
		return -1;
	if(out)
		out->clear();
	while(1)
	{
		char c = (char)fgetc(f);
		if(feof(f))
			break;
		if(out)
			out->append(c);
		if(showOutput)
			fputc(c, stdout);
	}
	int ret = pclose(f);
	if(ret == -1)
		return -1;
	return ret;
}

int qc_runprogram(const QString &prog, const QStringList &args, QByteArray *out, bool showOutput)
{
	QString fullcmd = prog;
	QString argstr = args.join(" ");
	if(!argstr.isEmpty())
		fullcmd += QString(" ") + argstr;
	return qc_runcommand(fullcmd, out, showOutput);

	// TODO: use QProcess once it is fixed
	/*
	QProcess process;
	if(showOutput)
		process.setReadChannelMode(ForwardedChannels);
	process.start(prog, args);
	process.waitForFinished(-1);
	return process.exitCode();
	*/
}

bool qc_removedir(const QString &dirPath)
{
	QDir dir(dirPath);
	if(!dir.exists())
		return false;
	QStringList list = dir.entryList();
	foreach(QString s, list)
	{
		if(s == "." || s == "..")
			continue;
		QFileInfo fi(dir.filePath(s));
		if(fi.isDir())
		{
			if(!qc_removedir(fi.filePath()))
				return false;
		}
		else
		{
			if(!dir.remove(s))
				return false;
		}
	}
	QString dirName = dir.dirName();
	if(!dir.cdUp())
		return false;
	if(!dir.rmdir(dirName))
		return false;
	return true;
}

void qc_splitcflags(const QString &cflags, QStringList *incs, QStringList *otherflags)
{
	incs->clear();
	otherflags->clear();

	QStringList cflagsList = cflags.split(" ");
	for(int n = 0; n < cflagsList.count(); ++n)
	{
		QString str = cflagsList[n];
		if(str.startsWith("-I"))
		{
			// we want everything except the leading "-I"
			incs->append(str.remove(0, 2));
		}
		else
		{
			// we want whatever is left
			otherflags->append(str);
		}
	}
}

QString qc_escapeArg(const QString &str)
{
	QString out;
	for(int n = 0; n < (int)str.length(); ++n) {
		if(str[n] == '-')
			out += '_';
		else
			out += str[n];
	}
	return out;
}

//----------------------------------------------------------------------------
// ConfObj
//----------------------------------------------------------------------------
ConfObj::ConfObj(Conf *c)
{
	conf = c;
	conf->added(this);
	required = false;
	disabled = false;
	success = false;
}

ConfObj::~ConfObj()
{
}

QString ConfObj::checkString() const
{
	return QString("Checking for %1 ...").arg(name());
}

QString ConfObj::resultString() const
{
	if(success)
		return "yes";
	else
		return "no";
}

//----------------------------------------------------------------------------
// qc_internal_pkgconfig
//----------------------------------------------------------------------------
class qc_internal_pkgconfig : public ConfObj
{
public:
	QString pkgname, desc;
	VersionMode mode;
	QString req_ver;

        qc_internal_pkgconfig(Conf *c, const QString &_name, const QString &_desc, VersionMode _mode, const QString &_req_ver) : ConfObj(c)
	{
		pkgname = _name;
		desc = _desc;
		mode = _mode;
		req_ver = _req_ver;
	}

	QString name() const { return desc; }
	QString shortname() const { return pkgname; }

	bool exec()
	{
		QStringList incs;
		QString version, libs, other;
		if(!conf->findPkgConfig(pkgname, mode, req_ver, &version, &incs, &libs, &other))
			return false;

		for(int n = 0; n < incs.count(); ++n)
			conf->addIncludePath(incs[n]);
		if(!libs.isEmpty())
			conf->addLib(libs);
		//if(!other.isEmpty())
		//	conf->addExtra(QString("QMAKE_CFLAGS += %1\n").arg(other));
		return true;
	}
};

//----------------------------------------------------------------------------
// Conf
//----------------------------------------------------------------------------
Conf::Conf()
{
	// TODO: no more vars?
	//vars.insert("QMAKE_INCDIR_X11", new QString(X11_INC));
	//vars.insert("QMAKE_LIBDIR_X11", new QString(X11_LIBDIR));
	//vars.insert("QMAKE_LIBS_X11",   new QString(X11_LIB));
	//vars.insert("QMAKE_CC", CC);

	debug_enabled = false;
}

Conf::~Conf()
{
	qDeleteAll(list);
}

void Conf::added(ConfObj *o)
{
	list.append(o);
}

QString Conf::getenv(const QString &var)
{
	return qc_getenv(var);
}

void Conf::debug(const QString &s)
{
	if(debug_enabled)
	{
		if(first_debug)
			printf("\n");
		first_debug = false;
		printf(" * %s\n", qPrintable(s));
	}
}

bool Conf::exec()
{
	for(int n = 0; n < list.count(); ++n)
	{
		ConfObj *o = list[n];

		// if this was a disabled-by-default option, check if it was enabled
		if(o->disabled)
		{
			QString v = QString("QC_ENABLE_") + qc_escapeArg(o->shortname());
			if(getenv(v) != "Y")
				continue;
		}
		// and the opposite?
		else
		{
			QString v = QString("QC_DISABLE_") + qc_escapeArg(o->shortname());
			if(getenv(v) == "Y")
				continue;
		}

		bool output = true;
		QString check = o->checkString();
		if(check.isEmpty())
			output = false;

		if(output)
		{
			printf("%s", check.toLatin1().data());
			fflush(stdout);
		}

		first_debug = true;
		bool ok = o->exec();
		o->success = ok;

		if(output)
		{
			QString result = o->resultString();
			if(!first_debug)
				printf(" -> %s\n", result.toLatin1().data());
			else
				printf(" %s\n", result.toLatin1().data());
		}

		if(!ok && o->required)
		{
			printf("\nError: need %s!\n", o->name().toLatin1().data());
			return false;
		}
	}
	return true;
}

QString Conf::qvar(const QString &s)
{
	return vars.value(s);
}

QString Conf::expandIncludes(const QString &inc)
{
	return QString("-I") + inc;
}

QString Conf::expandLibs(const QString &lib)
{
	return QString("-L") + lib;
}

int Conf::doCommand(const QString &s, QByteArray *out)
{
	debug(QString("[%1]").arg(s));
	int r = qc_runcommand(s, out, debug_enabled);
	debug(QString("returned: %1").arg(r));
	return r;
}

int Conf::doCommand(const QString &prog, const QStringList &args, QByteArray *out)
{
	QString fullcmd = prog;
	QString argstr = args.join(" ");
	if(!argstr.isEmpty())
		fullcmd += QString(" ") + argstr;
	debug(QString("[%1]").arg(fullcmd));
	int r = qc_runprogram(prog, args, out, debug_enabled);
	debug(QString("returned: %1").arg(r));
	return r;
}

bool Conf::doCompileAndLink(const QString &filedata, const QStringList &incs, const QString &libs, const QString &proextra, int *retcode)
{
	QDir tmp(".qconftemp");
	if(!tmp.mkdir("atest"))
	{
		debug("unable to create atest dir");
		return false;
	}
	QDir dir(tmp.filePath("atest"));
	if(!dir.exists())
	{
		debug("atest dir does not exist");
		return false;
	}

	QString fname = dir.filePath("atest.cpp");
	QString out = "atest";
	QFile f(fname);
	if(!f.open(QFile::WriteOnly | QFile::Truncate))
	{
		debug("unable to open atest.cpp for writing");
		return false;
	}
	if(f.write(filedata.toLatin1()) == -1)
	{
		debug("error writing to atest.cpp");
		return false;
	}
	f.close();

	debug(QString("Wrote atest.cpp:\n%1").arg(filedata));

	QString pro = QString(
		"CONFIG  += console\n"
		"CONFIG  -= qt app_bundle\n"
		"SOURCES += atest.cpp\n");
	QString inc = incs.join(" ");
	if(!inc.isEmpty())
		pro += "INCLUDEPATH += " + inc + '\n';
	if(!libs.isEmpty())
		pro += "LIBS += " + libs + '\n';
	pro += proextra;

	fname = dir.filePath("atest.pro");
	f.setFileName(fname);
	if(!f.open(QFile::WriteOnly | QFile::Truncate))
	{
		debug("unable to open atest.pro for writing");
		return false;
	}
	if(f.write(pro.toLatin1()) == -1)
	{
		debug("error writing to atest.pro");
		return false;
	}
	f.close();

	debug(QString("Wrote atest.pro:\n%1").arg(pro));

	QString oldpath = QDir::currentPath();
	QDir::setCurrent(dir.path());

	bool ok = false;
	int r = doCommand(qmake_path, QStringList() << "atest.pro");
	if(r == 0)
	{
		r = doCommand(maketool, QStringList());
		if(r == 0)
		{
			ok = true;
			if(retcode)
				*retcode = doCommand(QString("./") + out, QStringList());
		}
		r = doCommand(maketool, QStringList() << "distclean");
		if(r != 0)
			debug("error during atest distclean");
	}

	QDir::setCurrent(oldpath);

	// cleanup
	//dir.remove("atest.pro");
	//dir.remove("atest.cpp");
	//tmp.rmdir("atest");

	// remove whole dir since distclean doesn't always work
	qc_removedir(tmp.filePath("atest"));

	if(!ok)
		return false;
	return true;
}

bool Conf::checkHeader(const QString &path, const QString &h)
{
	QFileInfo fi(path + '/' + h);
	if(fi.exists())
		return true;
	return false;
}

bool Conf::findHeader(const QString &h, const QStringList &ext, QString *inc)
{
	if(checkHeader("/usr/include", h))
	{
		*inc = "";
		return true;
	}
	QStringList dirs;
	dirs += "/usr/local/include";
	dirs += ext;
	for(QStringList::ConstIterator it = dirs.begin(); it != dirs.end(); ++it)
	{
		if(checkHeader(*it, h))
		{
			*inc = *it;
			return true;
		}
	}
	return false;
}

bool Conf::checkLibrary(const QString &path, const QString &name)
{
	QString str =
		//"#include <stdio.h>\n"
		"int main()\n"
		"{\n"
		//"    printf(\"library checker running\\\\n\");\n"
		"    return 0;\n"
		"}\n";

	QString libs;
	if(!path.isEmpty())
		libs += QString("-L") + path + ' ';
	libs += QString("-l") + name;
	if(!doCompileAndLink(str, QStringList(), libs, QString()))
		return false;
	return true;
}

bool Conf::findLibrary(const QString &name, QString *lib)
{
	if(checkLibrary("", name))
	{
		*lib = "";
		return true;
	}
	if(checkLibrary("/usr/local/lib", name))
	{
		*lib = "/usr/local/lib";
		return true;
	}
	return false;
}

QString Conf::findProgram(const QString &prog)
{
	return qc_findprogram(prog);
}

bool Conf::findSimpleLibrary(const QString &incvar, const QString &libvar, const QString &incname, const QString &libname, QString *incpath, QString *libs)
{
	QString inc, lib;
	QString s;

	s = getenv(incvar);
	if(!s.isEmpty()) {
		if(!checkHeader(s, incname))
			return false;
		inc = s;
	}
	else {
		if(!findHeader(incname, QStringList(), &s))
			return false;
		inc = s;
	}

	s = getenv(libvar);
	if(!s.isEmpty()) {
		if(!checkLibrary(s, libname))
			return false;
		lib = s;
	}
	else {
		if(!findLibrary(libname, &s))
			return false;
		lib = s;
	}

	QString lib_out;
	if(!lib.isEmpty())
		lib_out += QString("-L") + s;
	lib_out += QString("-l") + libname;

	*incpath = inc;
	*libs = lib_out;
	return true;
}

bool Conf::findFooConfig(const QString &path, QString *version, QStringList *incs, QString *libs, QString *otherflags)
{
	QStringList args;
	QByteArray out;
	int ret;

	args += "--version";
	ret = doCommand(path, args, &out);
	if(ret != 0)
		return false;

	QString version_out = QString::fromLatin1(out).trimmed();

	args.clear();
	args += "--libs";
	ret = doCommand(path, args, &out);
	if(ret != 0)
		return false;

	QString libs_out = QString::fromLatin1(out).trimmed();

	args.clear();
	args += "--cflags";
	ret = doCommand(path, args, &out);
	if(ret != 0)
		return false;

	QString cflags = QString::fromLatin1(out).trimmed();

	QStringList incs_out, otherflags_out;
	qc_splitcflags(cflags, &incs_out, &otherflags_out);

	*version = version_out;
	*incs = incs_out;
	*libs = libs_out;
	*otherflags = otherflags_out.join(" ");
	return true;
}

bool Conf::findPkgConfig(const QString &name, VersionMode mode, const QString &req_version, QString *version, QStringList *incs, QString *libs, QString *otherflags)
{
	QStringList args;
	QByteArray out;
	int ret;

	args += name;
	args += "--exists";
	ret = doCommand("pkg-config", args, &out);
	if(ret != 0)
		return false;

	if(mode != VersionAny)
	{
		args.clear();
		args += name;
		if(mode == VersionMin)
			args += QString("--atleast-version=%1").arg(req_version);
		else if(mode == VersionMax)
			args += QString("--max-version=%1").arg(req_version);
		else
			args += QString("--exact-version=%1").arg(req_version);
		ret = doCommand("pkg-config", args, &out);
		if(ret != 0)
			return false;
	}

	args.clear();
	args += name;
	args += "--modversion";
	ret = doCommand("pkg-config", args, &out);
	if(ret != 0)
		return false;

	QString version_out = QString::fromLatin1(out).trimmed();

	args.clear();
	args += name;
	args += "--libs";
	ret = doCommand("pkg-config", args, &out);
	if(ret != 0)
		return false;

	QString libs_out = QString::fromLatin1(out).trimmed();

	args.clear();
	args += name;
	args += "--cflags";
	ret = doCommand("pkg-config", args, &out);
	if(ret != 0)
		return false;

	QString cflags = QString::fromLatin1(out).trimmed();

	QStringList incs_out, otherflags_out;
	qc_splitcflags(cflags, &incs_out, &otherflags_out);

	*version = version_out;
	*incs = incs_out;
	*libs = libs_out;
	*otherflags = otherflags_out.join(" ");
	return true;
}

void Conf::addDefine(const QString &str)
{
	if(DEFINES.isEmpty())
		DEFINES = str;
	else
		DEFINES += QString(" ") + str;
	debug(QString("DEFINES += %1").arg(str));
}

void Conf::addLib(const QString &str)
{
	if(LIBS.isEmpty())
		LIBS = str;
	else
		LIBS += QString(" ") + str;
	debug(QString("LIBS += %1").arg(str));
}

void Conf::addIncludePath(const QString &str)
{
	if(INCLUDEPATH.isEmpty())
		INCLUDEPATH = str;
	else
		INCLUDEPATH += QString(" ") + str;
	debug(QString("INCLUDEPATH += %1").arg(str));
}

void Conf::addExtra(const QString &str)
{
	extra += str + '\n';
	debug(QString("extra += %1").arg(str));
}

//----------------------------------------------------------------------------
// main
//----------------------------------------------------------------------------
#include "conf4.moc"

#ifdef HAVE_MODULES
# include"modules.cpp"
#endif

int main()
{
	Conf *conf = new Conf;
	ConfObj *o;
	o = 0;
#ifdef HAVE_MODULES
# include"modules_new.cpp"
#endif

	conf->debug_enabled = (qc_getenv("QC_VERBOSE") == "Y") ? true: false;
	if(conf->debug_enabled)
		printf(" -> ok\n");
	else
		printf("ok\n");

	QString confCommand = qc_getenv("QC_COMMAND");
	QString proName = qc_getenv("QC_PROFILE");
	conf->qmake_path = qc_getenv("QC_QMAKE");
	conf->qmakespec = qc_getenv("QC_QMAKESPEC");
	conf->maketool = qc_getenv("QC_MAKETOOL");

	if(conf->debug_enabled)
		printf("conf command: [%s]\n", qPrintable(confCommand));

	QString confPath = qc_findself(confCommand);
	if(confPath.isEmpty())
	{
		printf("Error: cannot find myself; rerun with an absolute path\n");
		return 1;
	}

	QString srcdir = QFileInfo(confPath).absolutePath();
	QString builddir = QDir::current().absolutePath();
	QString proPath = QDir(srcdir).filePath(proName);

	if(conf->debug_enabled)
	{
		printf("conf path:    [%s]\n", qPrintable(confPath));
		printf("srcdir:       [%s]\n", qPrintable(srcdir));
		printf("builddir:     [%s]\n", qPrintable(builddir));
		printf("profile:      [%s]\n", qPrintable(proPath));
		printf("qmake path:   [%s]\n", qPrintable(conf->qmake_path));
		printf("qmakespec:    [%s]\n", qPrintable(conf->qmakespec));
		printf("make tool:    [%s]\n", qPrintable(conf->maketool));
		printf("\n");
	}

	bool success = false;
	if(conf->exec())
	{
		QFile f("conf.pri");
		if(!f.open(QFile::WriteOnly | QFile::Truncate))
		{
			printf("Error writing %s\n", qPrintable(f.fileName()));
			return 1;
		}

		QString str;
		str += "# qconf\n\n";

		QString var;
		var = qc_getenv("PREFIX");
		if(!var.isEmpty())
			str += QString("PREFIX = %1\n").arg(var);
		var = qc_getenv("BINDIR");
		if(!var.isEmpty())
			str += QString("BINDIR = %1\n").arg(var);
		var = qc_getenv("INCDIR");
		if(!var.isEmpty())
			str += QString("INCDIR = %1\n").arg(var);
		var = qc_getenv("LIBDIR");
		if(!var.isEmpty())
			str += QString("LIBDIR = %1\n").arg(var);
		var = qc_getenv("DATADIR");
		if(!var.isEmpty())
			str += QString("DATADIR = %1\n").arg(var);
		str += '\n';

		if(qc_getenv("QC_STATIC") == "Y")
			str += "CONFIG += staticlib\n";

		// TODO: don't need this?
		//str += "QT_PATH_PLUGINS = " + QString(qInstallPathPlugins()) + '\n';

		if(!conf->DEFINES.isEmpty())
			str += "DEFINES += " + conf->DEFINES + '\n';
		if(!conf->INCLUDEPATH.isEmpty())
			str += "INCLUDEPATH += " + conf->INCLUDEPATH + '\n';
		if(!conf->LIBS.isEmpty())
			str += "LIBS += " + conf->LIBS + '\n';
		if(!conf->extra.isEmpty())
			str += conf->extra;
		str += '\n';

		QByteArray cs = str.toLatin1();
		f.write(cs);
		f.close();
		success = true;
	}
	QString qmake_path = conf->qmake_path;
	QString qmakespec = conf->qmakespec;
	delete conf;

	if(!success)
		return 1;

	// run qmake on the project file
	QStringList args;
	if(!qmakespec.isEmpty())
	{
		args += "-spec";
		args += qmakespec;
	}
	args += proPath;
	int ret = qc_runprogram(qmake_path, args, 0, true);
	if(ret != 0)
		return 1;

	return 0;
}

EOT
cat >$1/conf4.pro <<EOT
CONFIG  += console
CONFIG  -= app_bundle
QT      -= gui
TARGET   = conf
DESTDIR  = \$\$PWD

HEADERS += conf4.h
SOURCES += conf4.cpp


DEFINES += HAVE_MODULES

EOT
}

export PREFIX
export BINDIR
export DATADIR
export EX_QTDIR
export QC_CERTSTORE_PATH
export QC_DISABLE_bundled_qca
export QC_DISABLE_openssl
export QC_WITH_OPENSSL_INC
export QC_WITH_OPENSSL_LIB
export QC_WITH_ZLIB_INC
export QC_WITH_ZLIB_LIB
export QC_ENABLE_universal
export QC_DISABLE_qdbus
export QC_DISABLE_growl
export QC_WITH_GROWL
export QC_DISABLE_libnotify
export QC_DISABLE_sparkle
export QC_WITH_SPARKLE
export QC_DISABLE_xss
export QC_DISABLE_ghbnr
export QC_DISABLE_aspell
export QC_WITH_ASPELL_INC
export QC_WITH_ASPELL_LIB
export QC_DISABLE_plugins
export QC_ENABLE_PLUGINS
export QC_ENABLE_DEBUG
export QC_VERBOSE
rm -rf .qconftemp
(
	mkdir .qconftemp
	gen_files .qconftemp
	cd .qconftemp
	if [ ! -z "$qm_spec" ]; then
		$qm -spec $qm_spec conf4.pro >/dev/null
	else
		$qm conf4.pro >/dev/null
	fi
	$MAKE clean >/dev/null 2>&1
	$MAKE >../conf.log 2>&1
)

if [ "$?" != "0" ]; then
	rm -rf .qconftemp
	if [ "$QC_VERBOSE" = "Y" ]; then
		echo " -> fail"
	else
		echo "fail"
	fi
	printf "\n"
	printf "Reason: There was an error compiling 'conf'.  See conf.log for details.\n"
	printf "\n"
	show_qt_info
	if [ "$QC_VERBOSE" = "Y" ]; then
		echo "conf.log:"
		cat conf.log
	fi
	exit 1;
fi

QC_COMMAND=$0
export QC_COMMAND
QC_PROFILE=psi.pro
export QC_PROFILE
QC_QMAKE=$qm
export QC_QMAKE
QC_QMAKESPEC=$qm_spec
export QC_QMAKESPEC
QC_MAKETOOL=$MAKE
export QC_MAKETOOL
.qconftemp/conf
ret="$?"
if [ "$ret" = "1" ]; then
	rm -rf .qconftemp
	echo
	exit 1;
else
	if [ "$ret" != "0" ]; then
		rm -rf .qconftemp
		if [ "$QC_VERBOSE" = "Y" ]; then
			echo " -> fail"
		else
			echo "fail"
		fi
		echo
		echo "Reason: Unexpected error launching 'conf'"
		echo
		exit 1;
	fi
fi
rm -rf .qconftemp

echo
echo "Good, your configure finished.  Now run $MAKE."
echo
